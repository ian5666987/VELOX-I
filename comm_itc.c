// code by ntu ael

#include <string.h>

#include "C8051_SMBus.h"

#include "comm_generic.h"
#include "comm_internal.h"
#include "comm_itc.h"

#define ITC_ADDRESS 0xA2

// manual 5.2 page 35:

#define ITC_RESET     0xAA // ISIS ITC Reset
void Comm_txReset() {
  Comm_sendChar(ITC_RESET, ITC_ADDRESS);
}

// manual 5.2 page 36:

// DO NOT call this with buffer==i2c_txbuffer!
// length has to be 1, 2, ..., 235 (instead of 237 previously)
// use in combination with Comm_txAx25AndCwGet, to obtain if Comm_txAx25Put was successful
#define ITC_TX_AX25_FRAME     0x10 // ISIS ITC send AX.25 frame with default callsigns
void Comm_txAx25Put(void* buffer, short length) {
  comm_txbuffer[0] = ITC_TX_AX25_FRAME; // send ax25 frame and getting number of frames in rx buffer
  memcpy(&comm_txbuffer[1], buffer, length);
  Comm_sendChars(ITC_ADDRESS, 1 + length);
}

#define COMM_TX_AX25ANDCW_REPLY   1
char Comm_txAx25AndCwGet(char* numel) {
  short length;
  Comm_getChars(ITC_ADDRESS, COMM_TX_AX25ANDCW_REPLY);
  if (SMBus_isRxComplete(&length))
    if (length == COMM_TX_AX25ANDCW_REPLY) {
      *numel = g_itc.tx_available = comm_rxbuffer[0];
      return 1;
    }
  g_itc.tx_available = 0;
  ++comm_failCount;
  return 0;

}

// manual 5.2 page 37, 38: send ax25 with override callsigns

// manual 5.2
// page 40: set ax25 beacon with default callsigns
// page 41: set ax25 beacon with override callsigns
// page 42: set cw beacon for autonomous transmission
// page 43: clear beacon
//#define ITC_I2C_CLR_BCN    0x1F //ISIS ITC clear beacon
//void Comm_txClearBeacon() {
//  Comm_sendChar(ITC_I2C_CLR_BCN, ITC_ADDRESS);
//}

// manual 5.2 page 44: set default ax25 TO callsign
// TODO

// manual 5.2 page 45: set default ax25 FROM callsign
// TODO

// manual 5.2 page 46:

// Set transmitter idle state
// 0 -> transmitter is turned off when idle
// 1 -> transmitter remains on when idle
#define ITC_SET_TX_IDLE_STATE     0x24  // ISIS ITC set transmitter idle state
void Comm_setTxIdleState(char value) {
  comm_txbuffer[0] = ITC_SET_TX_IDLE_STATE; // set ax25 idle state
  comm_txbuffer[1] = value;
  Comm_sendChars(ITC_ADDRESS, 2);
  if (value) // assume that command was effective; later trxuv hk collection may update status bits
    g_itc.tx_status |= COMM_IDLE_STATUS_MASK;
  else
    g_itc.tx_status &= ~COMM_IDLE_STATUS_MASK;
}

// manual 5.2 page 47

// set transmitter output mode
// 0x00 - external telemetry mode: transmit the signal generated by another subsystem provided on the external telemetry input of the transceiver
// 0x01 - nominal telemetry mode: transmit the signal generated by the transceiver itself, i.e. the AX.25 and CW generating functions of the transceiver
// 0x03 - receiver loopback mode: transmit the signal that is received at the receiver, e.g. for use as an FM - DSB transponder
// warning: 'external telemetry', and 'receiver loopback' mode are not feasible for real operation on Velox-I
#define ITC_I2C_SET_TRN_OUTM    0x25 // ISIS ITC set transmitter output mode
void Comm_setTxOutputMode(char value) {
  comm_txbuffer[0] = ITC_I2C_SET_TRN_OUTM;
  comm_txbuffer[1] = value;
  Comm_sendChars(ITC_ADDRESS, 2);
}

// manual 5.2 page 48:

// call Comm_setTxBitrate with 0, 1, 2, 3
// 0 -> 1200bps
// 1 -> 2400bps
// 2 -> 4800bps
// 3 -> 9600bps
#define ITC_SET_AX25_TX_RATE    0x28   // ISIS ITC set AX.25 transmission bitrate
void Comm_setTxBitrate(char value) {
  comm_txbuffer[0] = ITC_SET_AX25_TX_RATE; // set ax25 transmission bitrate
  comm_txbuffer[1] = 1 << value;
  Comm_sendChars(ITC_ADDRESS, 2);
}

// manual 5.2 page 49:

// note: rate = 600/value. the higher the value, the slower the rate
// default rate is assumed to be 12 dots per second -> default value = 50
#define ITC_SET_CW_CHAR_RATE    0x29   //ISIS ITC set CW character transmission rate
// allowed range for value is 1, 2, ... 1200
// warning: experiments show that if value == 1 the comm module might send indefinitely
void Comm_setTxCwCharRate(short value) {
  comm_txbuffer[0] = ITC_SET_CW_CHAR_RATE;
  comm_txbuffer[1] = value;
  comm_txbuffer[2] = value >> 8;
  Comm_sendChars(ITC_ADDRESS, 3);
}

// manual 5.2 page 50:

#define ITC_TX_UPTIME    0x40 // ISIS ITC report transmitter uptime
void Comm_txUptimePut() {
  // 6.2.2.15 get tx uptime
  Comm_sendChar(ITC_TX_UPTIME, ITC_ADDRESS);
}

char Comm_txUptimeGet() {
  short length;
#define COMM_TX_UPTIME_REPLY 3
  Comm_getChars(ITC_ADDRESS, COMM_TX_UPTIME_REPLY);
  if (SMBus_isRxComplete(&length))
    if (length == COMM_TX_UPTIME_REPLY) {
      memcpy(&g_itc.tx_uptime_minutes, comm_rxbuffer, COMM_TX_UPTIME_REPLY);
      return 1;
    }
  ++comm_failCount;
  return 0;
}

// manual 5.2 page 51, 52: report tx state

#define ITC_I2C_TRN_STATE   0x41   // ISIS ITC report transmitter state
void Comm_txStatusPut() {
  // 6.2.2.16 get rx uptime
  Comm_sendChar(ITC_I2C_TRN_STATE, ITC_ADDRESS);
}

char Comm_txStatusGet() {
  short length;
#define COMM_TX_STATUS_REPLY 1
  Comm_getChars(ITC_ADDRESS, COMM_TX_STATUS_REPLY);
  // no default return value ...
  if (SMBus_isRxComplete(&length))
    if (length == COMM_TX_STATUS_REPLY && !(comm_rxbuffer[0] & 0x80)) { // highest bit has to be zero
      g_itc.tx_status = comm_rxbuffer[0];
      return 1;
    }
  ++comm_failCount;
  return 0;
}

