C51 COMPILER V9.02   COMM_ITC                                                              05/20/2014 11:03:51 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE COMM_ITC
OBJECT MODULE PLACED IN comm_itc.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE comm_itc.c LARGE OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          // code by ntu ael
   2          
   3          #include <string.h>
   4          
   5          #include "C8051_SMBus.h"
   6          
   7          #include "comm_generic.h"
   8          #include "comm_internal.h"
   9          #include "comm_itc.h"
  10          
  11          #define ITC_ADDRESS 0xA2
  12          
  13          // manual 5.2 page 35:
  14          
  15          #define ITC_RESET     0xAA // ISIS ITC Reset
  16          void Comm_txReset() {
  17   1        Comm_sendChar(ITC_RESET, ITC_ADDRESS);
  18   1      }
  19          
  20          // manual 5.2 page 36:
  21          
  22          // DO NOT call this with buffer==i2c_txbuffer!
  23          // length has to be 1, 2, ..., 235 (instead of 237 previously)
  24          // use in combination with Comm_txAx25AndCwGet, to obtain if Comm_txAx25Put was successful
  25          #define ITC_TX_AX25_FRAME     0x10 // ISIS ITC send AX.25 frame with default callsigns
  26          void Comm_txAx25Put(void* buffer, short length) {
  27   1        comm_txbuffer[0] = ITC_TX_AX25_FRAME; // send ax25 frame and getting number of frames in rx buffer
  28   1        memcpy(&comm_txbuffer[1], buffer, length);
  29   1        Comm_sendChars(ITC_ADDRESS, 1 + length);
  30   1      }
  31          
  32          #define COMM_TX_AX25ANDCW_REPLY   1
  33          char Comm_txAx25AndCwGet(char* numel) {
  34   1        short length;
  35   1        Comm_getChars(ITC_ADDRESS, COMM_TX_AX25ANDCW_REPLY);
  36   1        if (SMBus_isRxComplete(&length))
  37   1          if (length == COMM_TX_AX25ANDCW_REPLY) {
  38   2            *numel = g_itc.tx_available = comm_rxbuffer[0];
  39   2            return 1;
  40   2          }
  41   1        g_itc.tx_available = 0;
  42   1        ++comm_failCount;
  43   1        return 0;
  44   1      
  45   1      }
  46          
  47          // manual 5.2 page 37, 38: send ax25 with override callsigns
  48          
  49          // manual 5.2
  50          // page 40: set ax25 beacon with default callsigns
  51          // page 41: set ax25 beacon with override callsigns
  52          // page 42: set cw beacon for autonomous transmission
  53          // page 43: clear beacon
  54          //#define ITC_I2C_CLR_BCN    0x1F //ISIS ITC clear beacon
  55          //void Comm_txClearBeacon() {
C51 COMPILER V9.02   COMM_ITC                                                              05/20/2014 11:03:51 PAGE 2   

  56          //  Comm_sendChar(ITC_I2C_CLR_BCN, ITC_ADDRESS);
  57          //}
  58          
  59          // manual 5.2 page 44: set default ax25 TO callsign
  60          // TODO
  61          
  62          // manual 5.2 page 45: set default ax25 FROM callsign
  63          // TODO
  64          
  65          // manual 5.2 page 46:
  66          
  67          // Set transmitter idle state
  68          // 0 -> transmitter is turned off when idle
  69          // 1 -> transmitter remains on when idle
  70          #define ITC_SET_TX_IDLE_STATE     0x24  // ISIS ITC set transmitter idle state
  71          void Comm_setTxIdleState(char value) {
  72   1        comm_txbuffer[0] = ITC_SET_TX_IDLE_STATE; // set ax25 idle state
  73   1        comm_txbuffer[1] = value;
  74   1        Comm_sendChars(ITC_ADDRESS, 2);
  75   1        if (value) // assume that command was effective; later trxuv hk collection may update status bits
  76   1          g_itc.tx_status |= COMM_IDLE_STATUS_MASK;
  77   1        else
  78   1          g_itc.tx_status &= ~COMM_IDLE_STATUS_MASK;
  79   1      }
  80          
  81          // manual 5.2 page 47
  82          
  83          // set transmitter output mode
  84          // 0x00 - external telemetry mode: transmit the signal generated by another subsystem provided on the exte
             -rnal telemetry input of the transceiver
  85          // 0x01 - nominal telemetry mode: transmit the signal generated by the transceiver itself, i.e. the AX.25 
             -and CW generating functions of the transceiver
  86          // 0x03 - receiver loopback mode: transmit the signal that is received at the receiver, e.g. for use as an
             - FM - DSB transponder
  87          // warning: 'external telemetry', and 'receiver loopback' mode are not feasible for real operation on Velo
             -x-I
  88          #define ITC_I2C_SET_TRN_OUTM    0x25 // ISIS ITC set transmitter output mode
  89          void Comm_setTxOutputMode(char value) {
  90   1        comm_txbuffer[0] = ITC_I2C_SET_TRN_OUTM;
  91   1        comm_txbuffer[1] = value;
  92   1        Comm_sendChars(ITC_ADDRESS, 2);
  93   1      }
  94          
  95          // manual 5.2 page 48:
  96          
  97          // call Comm_setTxBitrate with 0, 1, 2, 3
  98          // 0 -> 1200bps
  99          // 1 -> 2400bps
 100          // 2 -> 4800bps
 101          // 3 -> 9600bps
 102          #define ITC_SET_AX25_TX_RATE    0x28   // ISIS ITC set AX.25 transmission bitrate
 103          void Comm_setTxBitrate(char value) {
 104   1        comm_txbuffer[0] = ITC_SET_AX25_TX_RATE; // set ax25 transmission bitrate
 105   1        comm_txbuffer[1] = 1 << value;
 106   1        Comm_sendChars(ITC_ADDRESS, 2);
 107   1      }
 108          
 109          // manual 5.2 page 49:
 110          
 111          // note: rate = 600/value. the higher the value, the slower the rate
 112          // default rate is assumed to be 12 dots per second -> default value = 50
 113          #define ITC_SET_CW_CHAR_RATE    0x29   //ISIS ITC set CW character transmission rate
C51 COMPILER V9.02   COMM_ITC                                                              05/20/2014 11:03:51 PAGE 3   

 114          // allowed range for value is 1, 2, ... 1200
 115          // warning: experiments show that if value == 1 the comm module might send indefinitely
 116          void Comm_setTxCwCharRate(short value) {
 117   1        comm_txbuffer[0] = ITC_SET_CW_CHAR_RATE;
 118   1        comm_txbuffer[1] = value;
 119   1        comm_txbuffer[2] = value >> 8;
 120   1        Comm_sendChars(ITC_ADDRESS, 3);
 121   1      }
 122          
 123          // manual 5.2 page 50:
 124          
 125          #define ITC_TX_UPTIME    0x40 // ISIS ITC report transmitter uptime
 126          void Comm_txUptimePut() {
 127   1        // 6.2.2.15 get tx uptime
 128   1        Comm_sendChar(ITC_TX_UPTIME, ITC_ADDRESS);
 129   1      }
 130          
 131          char Comm_txUptimeGet() {
 132   1        short length;
 133   1      #define COMM_TX_UPTIME_REPLY 3
 134   1        Comm_getChars(ITC_ADDRESS, COMM_TX_UPTIME_REPLY);
 135   1        if (SMBus_isRxComplete(&length))
 136   1          if (length == COMM_TX_UPTIME_REPLY) {
 137   2            memcpy(&g_itc.tx_uptime_minutes, comm_rxbuffer, COMM_TX_UPTIME_REPLY);
 138   2            return 1;
 139   2          }
 140   1        ++comm_failCount;
 141   1        return 0;
 142   1      }
 143          
 144          // manual 5.2 page 51, 52: report tx state
 145          
 146          #define ITC_I2C_TRN_STATE   0x41   // ISIS ITC report transmitter state
 147          void Comm_txStatusPut() {
 148   1        // 6.2.2.16 get rx uptime
 149   1        Comm_sendChar(ITC_I2C_TRN_STATE, ITC_ADDRESS);
 150   1      }
 151          
 152          char Comm_txStatusGet() {
 153   1        short length;
 154   1      #define COMM_TX_STATUS_REPLY 1
 155   1        Comm_getChars(ITC_ADDRESS, COMM_TX_STATUS_REPLY);
 156   1        // no default return value ...
 157   1        if (SMBus_isRxComplete(&length))
 158   1          if (length == COMM_TX_STATUS_REPLY && !(comm_rxbuffer[0] & 0x80)) { // highest bit has to be zero
 159   2            g_itc.tx_status = comm_rxbuffer[0];
 160   2            return 1;
 161   2          }
 162   1        ++comm_failCount;
 163   1        return 0;
 164   1      }
 165          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    794    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.02   COMM_ITC                                                              05/20/2014 11:03:51 PAGE 4   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
